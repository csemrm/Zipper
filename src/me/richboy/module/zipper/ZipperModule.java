/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package me.richboy.module.zipper;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.util.TiConvert;

import android.net.Uri;


@Kroll.module(name="Zipper", id="me.richboy.module.zipper")
public class ZipperModule extends KrollModule
{

	// Standard Debugging variables
	private static final String LCAT = "ZipperModule";
	private static final boolean DBG = TiConfig.LOGD;
	private KrollFunction successFunction, errorFunction, progressFunction;
	private ArrayList<Object> fileList;
	private HashMap<String, String> errorMap;
	private HashMap<String, Double> progressMap;
	private HashMap<String, Object[]> successMap;
	private String source, dest;
	private boolean async;
	private boolean overwrite;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;

	public ZipperModule()
	{
		super();
		fileList = new ArrayList<Object>();
		errorMap = new HashMap<String, String>();
		successMap = new HashMap<String, Object[]>();
		progressMap = new HashMap<String, Double>();
		async = false;
		overwrite = true;
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		//Log.d(LCAT, "inside onAppCreate");
		// put module init code that needs to run when the application is created
	}
	
	@Override
	public void processProperties(KrollDict properties) {
		super.processProperties(properties);
		
		if( properties.containsKey("success") )
			successFunction = (KrollFunction) properties.get("success");
		if( properties.containsKey("error") )
			errorFunction = (KrollFunction) properties.get("error");
		if( properties.containsKey("progress") )
			progressFunction = (KrollFunction) properties.get("progress");
		if( properties.containsKey("async") )
			async = TiConvert.toBoolean(properties.get("async"));
		if( properties.containsKey("overwrite") )
			async = TiConvert.toBoolean(properties.get("overwrite"));
		
		if( properties.containsKey("file") )
			source = TiConvert.toString(properties.get("file"));
		else{
			errorMap.put("message", "Source File MUST be specified");
			errorMap.put("errorStack", "");
			if( errorFunction != null )
				errorFunction.callAsync(getKrollObject(), errorMap);
			return;
		}
		
		if( properties.containsKey("target") )
			dest = TiConvert.toString(properties.get("target"));
		else{
			errorMap.put("message", "Destination Target Directory MUST be specified");
			errorMap.put("errorStack", "");
			if( errorFunction != null )
				errorFunction.callAsync(getKrollObject(), errorMap);
			return;
		}
	}

	// Methods
	@Kroll.method
	public void unzip(KrollDict properties)
	{
		processProperties(properties);
		
		if(async){
			new Thread(new ZipperRunner()).start();
		}
		else
			new ZipperRunner().run();
	}
	
	private class ZipperRunner implements Runnable{
		public void run(){
			if(DBG)
				Log.i(LCAT, "source sent was: " + source);
			try{
				File file = new File(Uri.parse(source).getPath());
				File destFile = new File(Uri.parse(dest).getPath());
				
				if( !file.exists() ){
					if(DBG)
						Log.e(LCAT, "Source File - " + file.getAbsolutePath() + " does NOT exist");
					errorMap.put("message", "Source File - " + file.getAbsolutePath() + " does NOT exist");
					errorMap.put("errorStack", "");
					if( errorFunction != null )
						errorFunction.callAsync(getKrollObject(), errorMap);
					return;
				}
				
				if( destFile.getParentFile() == null && !destFile.exists() ){
					if(DBG)
						Log.e(LCAT, "Destination file - "+ destFile.getAbsolutePath() +" is not writtable");
					errorMap.put("message", "Destination file - "+ destFile.getAbsolutePath() +" is not writtable");
					errorMap.put("errorStack", "");
					if( errorFunction != null )
						errorFunction.callAsync(getKrollObject(), errorMap);
					return;
				}
				
				destFile.mkdirs();
				
				ZipFile zip = new ZipFile(file);
				int size = zip.size();
				zip.close();
				
				int entryCount = 0;
				
				FileInputStream fis = new FileInputStream(file);
				ZipInputStream zis = new ZipInputStream(fis);
				byte[] buffer = new byte[1024];
				
				
				ZipEntry ze;
				while( (ze = zis.getNextEntry()) != null ){
					if( ze.isDirectory() ){
						File d = new File(destFile, ze.getName());
						d.mkdirs();
					}
					else{
						File f = new File(destFile, ze.getName());
						f.getParentFile().mkdirs();
						
						if( !overwrite && f.exists() ){
							entryCount++;
							progressMap.put("progress", (double) entryCount / (double) size);
							progressFunction.callAsync(getKrollObject(), progressMap);
							
							continue;
						}
						
						if(f.exists())
							f.delete();
							
						f.createNewFile();
						
						fileList.add(f.getAbsolutePath());
						
						FileOutputStream fos = new FileOutputStream(f);
						int len;
						while( (len = zis.read(buffer)) > 0 ){
							fos.write(buffer, 0, len);
						}
						fos.close();
					}
					zis.closeEntry();
					
					entryCount++;
					progressMap.put("progress", (double) entryCount / (double) size);
					progressFunction.callAsync(getKrollObject(), progressMap);
				}
				
				zis.close();
				
				successMap.put("files", fileList.toArray());
				if( successFunction != null )
					successFunction.callAsync(getKrollObject(), successMap);
			}
			catch(Exception e){
				String errorMessage = "Error: ";
				for( StackTraceElement elem : e.getStackTrace() )
					errorMessage += "\n" + elem.toString();
				
				if( DBG )
					Log.e(LCAT, "Error: " + errorMessage);
				
				errorMap.put("message", e.getMessage());
				errorMap.put("errorStack", errorMessage);
				if( errorFunction != null )
					errorFunction.callAsync(getKrollObject(), errorMap);
			}
		}
	}
}

